function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import defaultTheme from './theme';
import createTextStyles from './createTextStyles';
import createColorStyles from './createColorStyles';

var deepmerge = require('deepmerge');
/**
 * Adds aliases to an array of keys
 *
 * @param {Array} arr The array to add aliases to
 */


var addAliases = function addAliases(arr) {
  arr.forEach(function (val, key) {
    arr[['sm', 'md', 'lg', 'xl', 'xxl'][key]] = val;
  });
  return arr;
};
/**
 * Create the palette based on passed in theme
 *
 * @param {Object=} palette The passed in palette
 * @param {Object}  theme   The passed in theme
 *
 * @returns {Object} The generated palette
 */


var createPalette = function createPalette(_ref) {
  var _ref$palette = _ref.palette,
      palette = _ref$palette === void 0 ? {} : _ref$palette,
      theme = _objectWithoutProperties(_ref, ["palette"]);

  var _theme$colors = theme.colors,
      lightBlue = _theme$colors.lightBlue,
      blue = _theme$colors.blue,
      darkBlue = _theme$colors.darkBlue,
      lightGreen = _theme$colors.lightGreen,
      green = _theme$colors.green,
      darkGreen = _theme$colors.darkGreen,
      white = _theme$colors.white,
      text = _theme$colors.text,
      lightRed = _theme$colors.lightRed,
      red = _theme$colors.red,
      darkRed = _theme$colors.darkRed,
      lightOrange = _theme$colors.lightOrange,
      orange = _theme$colors.orange,
      darkOrange = _theme$colors.darkOrange,
      lightYellow = _theme$colors.lightYellow,
      yellow = _theme$colors.yellow,
      lightPurple = _theme$colors.lightPurple,
      purple = _theme$colors.purple,
      pink = _theme$colors.pink,
      gray = _theme$colors.gray,
      borderGray = _theme$colors.borderGray,
      darkGray = _theme$colors.darkGray,
      lightGray = _theme$colors.lightGray,
      buttonGray = _theme$colors.buttonGray;
  return deepmerge({
    primary: {
      light: lightBlue,
      base: blue,
      dark: darkBlue
    },
    secondary: {
      light: lightGreen,
      base: green,
      dark: darkGreen
    },
    text: {
      lightest: white,
      light: gray,
      base: text,
      dark: '#001023'
    },
    success: {
      light: lightGreen,
      base: green,
      dark: darkGreen
    },
    error: {
      light: lightRed,
      base: red,
      dark: darkRed
    },
    warning: {
      light: lightRed,
      base: red,
      dark: darkRed
    },
    alert: {
      light: lightOrange,
      base: orange,
      dark: darkOrange
    },
    caution: {
      light: lightYellow,
      base: yellow,
      dark: '#b19a1d'
    },
    notify: {
      light: lightYellow,
      base: yellow,
      dark: '#b19a1d'
    },
    pricePrimary: {
      light: lightGreen,
      base: green,
      dark: darkGreen
    },
    priceSecondary: {
      light: blue,
      base: darkBlue,
      dark: '#002f6b'
    },
    strike: {
      base: red
    },
    promoPrimary: {
      light: lightPurple,
      base: purple,
      dark: '#550080'
    },
    promoSecondary: {
      light: '#fe649a',
      base: pink,
      dark: '#b12b5a'
    },
    border: {
      light: gray,
      base: borderGray,
      dark: darkGray
    },
    background: {
      lightest: white,
      light: lightGray,
      base: buttonGray,
      dark: gray,
      darkest: text
    }
  }, palette);
};
/**
 * Create the theme
 *
 * @param {Object}  theme             The theme to merge against the default
 * @param {Object=} customBreakpoints Custom breakpoints for the theme
 *
 * @returns {Object} The generated theme
 */


export default (function () {
  var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var customBreakpoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var mergedTheme = deepmerge(defaultTheme, theme);
  return _objectSpread({}, mergedTheme, {
    contrastRatio: mergedTheme.contrastRatio || 2.6,
    breakpoints: addAliases(customBreakpoints || mergedTheme.breakpoints),
    mediaQueries: addAliases(mergedTheme.mediaQueries),
    palette: createPalette(mergedTheme),
    colorStyles: createColorStyles(mergedTheme),
    textStyles: createTextStyles(mergedTheme)
  });
});